# Implementation Plan: Issue #7 - DX Improvements

**GitHub Issue**: https://github.com/fraiseql/confiture/issues/7
**Author**: evoludigit
**Status**: Planning

---

## Overview

This plan implements 7 developer experience improvements requested in Issue #7. The features are ordered by implementation dependency and complexity.

## Priority Order

| Priority | Feature | Complexity | Dependencies |
|----------|---------|------------|--------------|
| 1 | Top-Level Testing Imports | Low | None |
| 2 | Migration Loader Utility | Low | None |
| 3 | JSON Output for Status | Low | None |
| 4 | SQL-Only Migrations | Medium | Migration loader |
| 5 | Baseline Command | Medium | None |
| 6 | Migration Sandbox | Medium | Migration loader |
| 7 | Pytest Plugin | Medium | All testing utilities |

---

## Feature 1: Top-Level Testing Imports

**Current State**: Fixtures require deep imports:
```python
from confiture.testing.fixtures.schema_snapshotter import SchemaSnapshotter
from confiture.testing.fixtures.data_validator import DataValidator
```

**Proposed**: Convenience imports from top-level:
```python
from confiture.testing import (
    SchemaSnapshotter,
    DataValidator,
    MigrationRunner,
    load_migration,
)
```

### Implementation Steps

1. **Edit `python/confiture/testing/__init__.py`**:
   - Import all fixtures from `confiture.testing.fixtures`
   - Add `load_migration` function (Feature 2)
   - Update `__all__` to include all public utilities

### Files to Modify
- `python/confiture/testing/__init__.py`

### Acceptance Criteria
- [ ] `from confiture.testing import SchemaSnapshotter` works
- [ ] `from confiture.testing import DataValidator` works
- [ ] `from confiture.testing import MigrationRunner` works
- [ ] Existing deep imports still work (backwards compatible)

---

## Feature 2: Migration Loader Utility

**Current State**: Manual importlib dance required:
```python
import importlib.util
spec = importlib.util.spec_from_file_location("migration_003", migration_path)
module = importlib.util.module_from_spec(spec)
spec.loader.exec_module(module)
return module.MoveCatalogTables
```

**Proposed**: Simple loader function:
```python
from confiture.testing import load_migration

Migration003 = load_migration("003_move_catalog_tables")
# or by version
Migration003 = load_migration(version="003")
```

### Implementation Steps

1. **Create `python/confiture/testing/loader.py`**:
   ```python
   def load_migration(
       name: str | None = None,
       *,
       version: str | None = None,
       migrations_dir: Path | None = None,
   ) -> type[Migration]:
       """Load a migration class by name or version.

       Args:
           name: Migration filename without .py (e.g., "003_move_catalog_tables")
           version: Migration version prefix (e.g., "003")
           migrations_dir: Custom migrations directory (default: db/migrations)

       Returns:
           Migration class (not instance)

       Raises:
           MigrationNotFoundError: If migration file not found
           MigrationLoadError: If migration cannot be loaded

       Example:
           >>> Migration003 = load_migration("003_move_catalog_tables")
           >>> Migration003 = load_migration(version="003")
       """
   ```

2. **Implementation details**:
   - Use existing `load_migration_module()` and `get_migration_class()` from `core/connection.py`
   - Support both full name and version-only lookup
   - Auto-discover migrations directory if not specified
   - Return the class, not an instance

3. **Export from `confiture.testing.__init__.py`**

### Files to Create
- `python/confiture/testing/loader.py`

### Files to Modify
- `python/confiture/testing/__init__.py`

### Acceptance Criteria
- [ ] `load_migration("003_move_catalog_tables")` returns Migration class
- [ ] `load_migration(version="003")` finds migration by version prefix
- [ ] Clear error message if migration not found
- [ ] Works with custom `migrations_dir` parameter

---

## Feature 3: JSON Output for Status Command

**Current State**: `migrate status` outputs table only:
```
┌─────────┬────────────────────┬──────────────┐
│ Version │ Name               │ Status       │
├─────────┼────────────────────┼──────────────┤
│ 001     │ create_users       │ ✅ applied   │
│ 002     │ add_posts          │ ✅ applied   │
│ 003     │ move_catalog_tables│ ⏳ pending   │
└─────────┴────────────────────┴──────────────┘
```

**Proposed**: Add `--format json` flag:
```bash
confiture migrate status --format json
# {"applied": ["001", "002"], "pending": ["003"], "current": "002"}
```

### Implementation Steps

1. **Modify `python/confiture/cli/main.py`** - `migrate_status()` function:
   - Add `--format` / `-f` option with choices: `table`, `json`
   - Default to `table` for backwards compatibility
   - Create JSON output structure:
     ```python
     {
         "applied": ["001", "002"],
         "pending": ["003"],
         "current": "002",  # Highest applied version
         "total": 3,
         "migrations": [
             {"version": "001", "name": "create_users", "status": "applied"},
             {"version": "002", "name": "add_posts", "status": "applied"},
             {"version": "003", "name": "move_catalog_tables", "status": "pending"}
         ]
     }
     ```

2. **Add JSON serialization**:
   - Use `json.dumps()` with `indent=2` for pretty output
   - Support `--output` flag to save to file

### Files to Modify
- `python/confiture/cli/main.py`

### Acceptance Criteria
- [ ] `confiture migrate status` outputs table (backwards compatible)
- [ ] `confiture migrate status --format json` outputs valid JSON
- [ ] `confiture migrate status -f json -o status.json` saves to file
- [ ] JSON includes: applied, pending, current, total, migrations array

---

## Feature 4: SQL-Only Migration Files

**Current State**: Simple SQL requires Python boilerplate:
```python
class MoveCatalogTables(Migration):
    version = "003"
    name = "move_catalog_tables"

    def up(self):
        self.execute("""...""")

    def down(self):
        self.execute("""...""")
```

**Proposed Options**:

### Option A: Pure SQL File Pairs
```
db/migrations/
├── 003_move_catalog_tables.up.sql
├── 003_move_catalog_tables.down.sql
```

### Option B: SQL Attributes in Python
```python
class MoveCatalogTables(Migration):
    version = "003"
    name = "move_catalog_tables"

    up_sql = """
        ALTER TABLE tenant.tb_datasupplier SET SCHEMA catalog;
    """

    down_sql = """
        ALTER TABLE catalog.tb_datasupplier SET SCHEMA tenant;
    """
```

**Recommendation**: Implement **both options**:
- Option A for pure SQL migrations (no Python needed)
- Option B for Python migrations that just run SQL (less boilerplate)

### Implementation Steps

1. **Option B first (simpler)** - Modify `python/confiture/models/migration.py`:
   ```python
   class Migration(ABC):
       # New optional class attributes
       up_sql: str | None = None
       down_sql: str | None = None

       def up(self) -> None:
           if self.up_sql is not None:
               self.execute(self.up_sql)
           else:
               raise NotImplementedError(...)

       def down(self) -> None:
           if self.down_sql is not None:
               self.execute(self.down_sql)
           else:
               raise NotImplementedError(...)
   ```
   - Make `up()` and `down()` non-abstract with default implementation
   - Check for `up_sql`/`down_sql` attributes first

2. **Option A (SQL file pairs)** - Modify `python/confiture/core/migrator.py`:
   - Add `find_sql_migration_files()` to discover `.up.sql`/`.down.sql` pairs
   - Create `SQLMigration` wrapper class that loads SQL from files
   - Modify `find_pending()` to include SQL migrations
   - Version extraction: `003_move_catalog_tables.up.sql` → `"003"`

3. **Create `python/confiture/models/sql_migration.py`**:
   ```python
   class SQLMigration(Migration):
       """Migration loaded from .up.sql/.down.sql file pair."""

       def __init__(self, connection, up_file: Path, down_file: Path):
           self.up_file = up_file
           self.down_file = down_file
           # Extract version and name from filename
           ...

       def up(self):
           self.execute(self.up_file.read_text())

       def down(self):
           self.execute(self.down_file.read_text())
   ```

### Files to Create
- `python/confiture/models/sql_migration.py`

### Files to Modify
- `python/confiture/models/migration.py`
- `python/confiture/core/migrator.py`
- `python/confiture/core/connection.py` (add SQL migration discovery)

### Acceptance Criteria
- [ ] Python migrations with `up_sql`/`down_sql` work without implementing methods
- [ ] `.up.sql`/`.down.sql` file pairs discovered and executed
- [ ] SQL migrations appear in `migrate status`
- [ ] SQL migrations support `--dry-run`
- [ ] Checksums work for SQL migrations
- [ ] Mixed Python + SQL migrations in same directory work

---

## Feature 5: Baseline Command

**Current State**: No clear way to mark migrations as applied without running them.

**Proposed**:
```bash
confiture migrate baseline --through 002
# or
confiture migrate mark-applied 001 002
```

### Implementation Steps

1. **Add `baseline` subcommand to `migrate_app`** in `python/confiture/cli/main.py`:
   ```python
   @migrate_app.command("baseline")
   def migrate_baseline(
       through: str = typer.Option(
           ...,  # Required
           "--through",
           "-t",
           help="Mark all migrations through this version as applied"
       ),
       migrations_dir: Path = typer.Option(...),
       config: Path = typer.Option(...),
       dry_run: bool = typer.Option(False, "--dry-run"),
   ) -> None:
       """Mark migrations as applied without executing them.

       Use this to establish a baseline when:
       - Adopting confiture on an existing database
       - Setting up a new environment from a backup
       - Recovering from a failed migration state

       Example:
           confiture migrate baseline --through 002
           # Marks 001, 002 as applied (if pending)
       """
   ```

2. **Add `mark_applied()` method to `Migrator`** in `python/confiture/core/migrator.py`:
   ```python
   def mark_applied(
       self,
       migration_file: Path,
       reason: str = "baseline"
   ) -> None:
       """Mark a migration as applied without executing it.

       Records the migration in tracking table with:
       - execution_time_ms = 0
       - checksum = computed from file
       - A special marker in notes/metadata
       """
   ```

3. **Alternative: `mark-applied` command for specific versions**:
   ```python
   @migrate_app.command("mark-applied")
   def migrate_mark_applied(
       versions: list[str] = typer.Argument(..., help="Versions to mark as applied"),
       ...
   ) -> None:
       """Mark specific migrations as applied."""
   ```

### Files to Modify
- `python/confiture/cli/main.py`
- `python/confiture/core/migrator.py`

### Acceptance Criteria
- [ ] `confiture migrate baseline --through 002` marks 001, 002 as applied
- [ ] Baseline command requires `--config` to connect to database
- [ ] `--dry-run` shows what would be marked without changing DB
- [ ] Already-applied migrations are skipped gracefully
- [ ] Output shows each migration being marked
- [ ] Tracking table records baseline operations with `execution_time_ms = 0`

---

## Feature 6: Migration Testing Sandbox

**Current State**: Manual transaction management:
```python
# Current approach
conn = psycopg.connect(...)
try:
    migration.up()
    # assertions
finally:
    conn.rollback()  # Manual cleanup
```

**Proposed**: Context manager with automatic rollback:
```python
from confiture.testing import MigrationSandbox

with MigrationSandbox(db_url) as sandbox:
    migration = sandbox.load("003")
    migration.up()

    assert sandbox.validator.no_data_loss()
    assert sandbox.snapshotter.has_table("catalog.tb_datasupplier")

# Auto-rollback at end of context
```

### Implementation Steps

1. **Create `python/confiture/testing/sandbox.py`**:
   ```python
   class MigrationSandbox:
       """Test migrations in isolation with automatic rollback.

       Provides a sandboxed environment for migration testing:
       - Automatic transaction management (rollback on exit)
       - Pre-loaded testing utilities (validator, snapshotter)
       - Migration loading via load_migration()

       Example:
           with MigrationSandbox(db_url) as sandbox:
               migration = sandbox.load("003_move_tables")
               migration.up()
               assert sandbox.validator.constraints_valid()
       """

       def __init__(
           self,
           db_url: str | None = None,
           connection: psycopg.Connection | None = None,
           migrations_dir: Path | None = None,
       ):
           """Initialize sandbox.

           Args:
               db_url: Database connection URL
               connection: Existing connection (uses savepoint instead)
               migrations_dir: Custom migrations directory
           """
           ...

       def __enter__(self) -> "MigrationSandbox":
           # Start transaction or create savepoint
           # Initialize validator, snapshotter
           return self

       def __exit__(self, exc_type, exc_val, exc_tb) -> None:
           # Rollback transaction or savepoint
           # Close connection if we created it
           ...

       def load(self, name: str) -> Migration:
           """Load and instantiate a migration."""
           migration_class = load_migration(name, migrations_dir=self.migrations_dir)
           return migration_class(connection=self.connection)

       @property
       def validator(self) -> DataValidator:
           """Get data validator for this sandbox."""
           ...

       @property
       def snapshotter(self) -> SchemaSnapshotter:
           """Get schema snapshotter for this sandbox."""
           ...

       def capture_baseline(self) -> DataBaseline:
           """Capture data baseline before migration."""
           return self.validator.capture_baseline()

       def assert_no_data_loss(self, baseline: DataBaseline) -> None:
           """Assert no data was lost since baseline."""
           assert self.validator.no_data_loss(baseline)
   ```

2. **Export from `confiture.testing.__init__.py`**

### Files to Create
- `python/confiture/testing/sandbox.py`

### Files to Modify
- `python/confiture/testing/__init__.py`

### Acceptance Criteria
- [ ] `MigrationSandbox` auto-rolls back on context exit
- [ ] `sandbox.load("003")` returns instantiated migration
- [ ] `sandbox.validator` provides DataValidator
- [ ] `sandbox.snapshotter` provides SchemaSnapshotter
- [ ] Works with existing connection (uses savepoint)
- [ ] Works with URL (creates and cleans up connection)
- [ ] Exception in context manager still triggers rollback

---

## Feature 7: Pytest Plugin

**Current State**: Manual fixture wiring in every test file.

**Proposed Options**:

### Option A: Decorator Approach
```python
from confiture.testing.pytest import migration_test

@migration_test("003_move_catalog_tables")
class TestMigration003:
    def test_up_preserves_data(self, migration, validator):
        migration.up()
        assert validator.no_data_loss()
```

### Option B: Auto-Fixtures via Plugin
```python
# conftest.py
pytest_plugins = ["confiture.testing.pytest"]

# test file - fixtures auto-injected
def test_migration(confiture_sandbox, confiture_migration):
    confiture_migration.up()
    assert confiture_sandbox.validator.constraints_valid()
```

**Recommendation**: Implement **Option B** (pytest plugin with auto-fixtures) as primary, with Option A as optional decorator for migration-specific tests.

### Implementation Steps

1. **Create `python/confiture/testing/pytest_plugin.py`**:
   ```python
   """Pytest plugin for confiture migration testing.

   Usage:
       # conftest.py
       pytest_plugins = ["confiture.testing.pytest"]

       # or in pyproject.toml
       [tool.pytest.ini_options]
       plugins = ["confiture.testing.pytest"]
   """

   import pytest
   from confiture.testing import MigrationSandbox, load_migration


   @pytest.fixture
   def confiture_db_url():
       """Override this fixture to provide custom database URL."""
       import os
       return os.getenv("CONFITURE_TEST_DB_URL", "postgresql://localhost/confiture_test")


   @pytest.fixture
   def confiture_migrations_dir():
       """Override this fixture to provide custom migrations directory."""
       from pathlib import Path
       return Path("db/migrations")


   @pytest.fixture
   def confiture_sandbox(confiture_db_url, confiture_migrations_dir):
       """Provide a migration sandbox that auto-rolls back."""
       with MigrationSandbox(
           db_url=confiture_db_url,
           migrations_dir=confiture_migrations_dir
       ) as sandbox:
           yield sandbox


   @pytest.fixture
   def confiture_validator(confiture_sandbox):
       """Provide data validator from sandbox."""
       return confiture_sandbox.validator


   @pytest.fixture
   def confiture_snapshotter(confiture_sandbox):
       """Provide schema snapshotter from sandbox."""
       return confiture_sandbox.snapshotter


   # Optional: Decorator for migration-specific tests
   def migration_test(migration_name: str):
       """Decorator to inject migration fixture for specific migration."""
       def decorator(cls):
           @pytest.fixture
           def migration(self, confiture_sandbox):
               return confiture_sandbox.load(migration_name)

           cls.migration = migration
           return cls
       return decorator
   ```

2. **Register as pytest plugin entry point** in `pyproject.toml`:
   ```toml
   [project.entry-points."pytest11"]
   confiture = "confiture.testing.pytest_plugin"
   ```

3. **Export from `confiture.testing.pytest`** namespace:
   - Create `python/confiture/testing/pytest/__init__.py`
   - Re-export `migration_test` decorator

### Files to Create
- `python/confiture/testing/pytest_plugin.py`
- `python/confiture/testing/pytest/__init__.py`

### Files to Modify
- `pyproject.toml` (add entry point)
- `python/confiture/testing/__init__.py`

### Acceptance Criteria
- [ ] `pytest_plugins = ["confiture.testing.pytest"]` registers fixtures
- [ ] `confiture_sandbox` fixture available and auto-rolls back
- [ ] `confiture_validator` fixture available
- [ ] `confiture_snapshotter` fixture available
- [ ] `confiture_db_url` fixture is overridable
- [ ] `@migration_test("003")` decorator injects `migration` fixture
- [ ] Plugin auto-discovered when confiture installed

---

## Test Plan

### Unit Tests (per feature)

1. **Feature 1-2**: `tests/unit/test_testing_imports.py`
   - Test all imports work from `confiture.testing`
   - Test `load_migration()` with valid/invalid names

2. **Feature 3**: `tests/unit/test_cli_status_json.py`
   - Test JSON output format
   - Test `--format` flag parsing

3. **Feature 4**: `tests/unit/test_sql_migrations.py`
   - Test `up_sql`/`down_sql` attributes
   - Test SQL file pair discovery
   - Test `SQLMigration` class

4. **Feature 5**: `tests/unit/test_baseline.py`
   - Test baseline command parsing
   - Test `mark_applied()` logic

5. **Feature 6**: `tests/unit/test_sandbox.py`
   - Test context manager behavior
   - Test rollback on exception
   - Test savepoint mode

6. **Feature 7**: `tests/unit/test_pytest_plugin.py`
   - Test fixture registration
   - Test decorator behavior

### Integration Tests

- `tests/integration/test_dx_improvements.py`
  - End-to-end test with real database
  - Test all 7 features together

---

## Implementation Order

```
Week 1: Foundation
├── Feature 1: Top-level imports (0.5 day)
├── Feature 2: load_migration() (0.5 day)
├── Feature 3: JSON status output (0.5 day)
└── Tests for features 1-3 (0.5 day)

Week 2: Core Features
├── Feature 4: SQL migrations - Option B (1 day)
├── Feature 4: SQL migrations - Option A (1 day)
├── Feature 5: Baseline command (0.5 day)
└── Tests for features 4-5 (0.5 day)

Week 3: Testing Infrastructure
├── Feature 6: MigrationSandbox (1 day)
├── Feature 7: Pytest plugin (1 day)
└── Integration tests + documentation (1 day)
```

---

## Verification Commands

After each feature:
```bash
# Run tests
uv run pytest tests/unit/test_<feature>.py -v

# Type checking
uv run ty check python/confiture/

# Linting
uv run ruff check python/confiture/

# Full test suite
uv run pytest --cov=confiture
```

---

## DO NOT

- [ ] Break existing API - all changes must be backwards compatible
- [ ] Change migration file format requirements
- [ ] Modify tracking table schema
- [ ] Add required dependencies
- [ ] Remove existing CLI flags or options
